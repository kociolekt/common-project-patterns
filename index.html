<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Podstawy js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <!-- SLAJD TYTUŁOWY -->
        <section>
          <h1>Wzorce projektowe</h1>
          <h2>w praktyce</h2>
          <img src="https://pl.gravatar.com/userimage/96535938/f405f6eac9456fb4fe004bb989434528?size=200"/><br/>
          <a href="https://www.npmjs.com/~kociolekt">npm</a>, <a href="https://github.com/kociolekt">github</a>
        </section>

        <!-- AGENDA -->
        <section>
          <h2>Agenda</h2>
          <ul>
            <li>O czym nie jest</li>
            <li>Po co?</li>
            <li>Obiektowość w praktyce</li>
            <li>Singleton</li>
            <!--
            Kreacyjny wzorzec projektowy, którego celem jest ograniczenie możliwości tworzenia obiektów danej klasy do jednej instancji oraz zapewnienie globalnego dostępu do stworzonego obiektu.
            Tak mówią. Co to oznacza w praktyce? Oznacza to że z każdego miejsca
            gdzie można importować moduł z Singletonem, mamy dostęp do tego samego obiektu.

            <a href="/examples/singleton.html">Przykład live</a>




            // Napisać eveter oparty na DOM
            -->

            <li>Mediator</li>
            <!--// Dobrym przykladem estimationEdit.js
            // Wersja sprzed przerobienia na mediatora
            // Wersja po przerobieniu na mediatora
            // Wnioski-->
            <li>Reactor</li>
            <!--// EstimationEdit, Costs, i inne widgety
            // Wersja sprzed przerobienia na Obserwator
            // Wersja po przerobieuniu na obserwator
            // Jakikolwiek eventer (Simple-Eventer lub wykorzystanie eventow DOM)-->
            <li>tbc</li>
          </ul>
        </section>

        <!-- O CZYMNIE JEST -->
        <section>
          <h2>O czym nie jest</h2>
          <p>Dużo praktyki mało teorii</p>
          <ul>
            <li>Obiektowość - paradygmat programowania w informatyce</li>
            <li>Klasa - definicja obiektu</li>
            <li>Instancja - pojedynczy obiekt pewnej klasy</li>
            <li>Dziedziczenie - współdzielenie funkcjonalności</li>
            <li>Hermetyacja - ukrywanie składowych</li>
            <li>Wzorce - gotowe rozwiązania</li>
          </ul>
          <aside class="notes">
            Nie będę mówił o tym że obiektowość to zbiór pojęć i teorii wykorzystywanych w informatyce do programowania z pomocą klasy i obiektu.
            Nie będę też mówił o tym że obiektowość w javascriptcie to tylko imitacja obiektowości z obiektowych języków programowania.
            Nie powiem też że klasa jest częściową lub całkowitą definicja obiektu. Tak nawiasem mówiąc to nazwy klas pisze się wielką literą.
            Nie zamierzam też tłumaczyć że instancja jest pojedynczym wystąpieniem obiektu zgodnego z definicją zapisaną w Klasie.
            Nie chcę wspominać o dziedziczeniu jako mechanizmie współdzielenia fukcjonalności pomiędzy klsasami.
            Ani mi w głowie mówić o ukrywanie pewnych składowych elementów obiektu przy pomocy hermetyzacji;
            a juz na pewno nie będę zanudzał was teorią na temat uniwersalnych sprawdzonych w praktyce rozwiązań powtarzalnych problemów projektowych.
            Wszystkie te elementy postaram się pokazać od strony praktycznej.
          </aside>
        </section>

        <!-- PO CO? -->
        <section>
          <section>
            <h2>Po co?</h2>
            <p>Do czego służą wzorce projektowe i po co nam one</p>
            <ul>
              <li>Jak to z Toolboxem było</li>
              <li>Najpierw myślimy potem robimy</li>
              <li>Poziomy abstrakcji</li>
              <li>Przykład z jajkiem</li>
              <li>I właśnie po to są wzorce</li>
            </ul>
          </section>
          <section>
            <h2>Toolbox</h2>
            <p>Duży projekt</p>
            <a href="img/toolbox.png" target="_blank"><img src="img/toolbox.png" /></a>
            <aside class="notes">
              Napisany w ostatnio bardzo popularnej architektórze mikroserwisów.
              Jak na razie składa się z kilkunastu serwisów z czego 8 z nich
              jako interfejs wykorzystuje technologie webowe.
              Wraz z modułami es6 weszła możliwość wygodniejszego definiowania klas.
              Postanowiłem zobaczyć jak sprawdzi się pisanie bardzo obiektowego kodu
              I zacząłem trafiać na problemy związane z komunikacją pomiędzy
              obiektami - przestałem orientować się który obiekt z którym się
              komunikuje w którym momencie.
            </aside>
          </section>
          <section>
            <h2>Najpierw myślimy potem robimy</h2>
            <p>Warto poświęcić chwilę żeby się zastanowić nim siądzie się do kodu. Nawet z kartką i długopisem w ręku.</p>
            <a href="img/toolbox.png" target="_blank"><img src="img/toolbox.png" /></a>
            <aside class="notes">
              Więc zastanowiłem się chwilę i rozpisałem sobie Hierarchię obiektów i metod.
              Analizując potrzeby projektu zauważyłem że łatwo można podzielić
              go na "warstwy" o różnym stopniu szczegółowości.
              W ten sposób podział skończyłem ze Splitem, Serwisem, Stroną, Widgetem,
              Komponentem i Pluginem.
              Do tego założyłem ograniczenia w wielkości klasy oraz metody.
              300 linijek dla klasy i 20 linijek dla metody.
              Nie wspomnę już o zasadzie że jedna metoda powinna wykonywać jedną czynność.
              Do tego każdy z elementów dzielę na funkcjonalności a metody uruchamiające
              funkcjonalności poprzedzam słowem init.
            </aside>
          </section>
          <section>
            <h2>Poziomy abstrakcji</h2>
            <p>Dodatkowy czinnik wpływający na jakość kodu.</p>
            <aside class="notes">
              Pozatym jest jeszcze jeden współczynnik który pomaga w organizacji
              kodu. W jednej z książek nazwali go poziomem abstrakcji.
              Pokażę to na przykładzie przepisu na jajecznicę.
            </aside>
          </section>
          <section>
            <h2>Przykład z jajkiem</h2>
            <p>                Przepis na jajecznicę
              - Rozpuścić masło na małej patelni
              - Wrzucić na stopione masełko szynkę pokrojoną w małe kwadraciki oraz drobno posiekany szczypiorek
              - rozbić ostrym nożem skorupki jajek i zawartość wylewać na patelnię
              - Dodać trochę soli oraz pieprzu i mieszać, aż do momentu ścięcia się jajek

              Często kodzie wygląda to tak:

              dodaj(maslo)

              while(maslo.nieJestStopione){
              for( atom in atomyWProbceMasla){
              atom.dostarczEnergii
              }
              }
              dodaj(pokrojona Szynka)

              while(szczypiorek.jestCaly){
              oddziaływuj nożem na sieć krystaliczną szczypiorku
              }

              dodaj(szczypiorek)

              noż.dodajEnerigiiPotencjalnej
              noz.zamieńEnergięPotencjalnąNaKinetyczną
              noż.uderzW(jajko)

              dodaj(zawartośćJajka)

              dodaj(sól)

              for(ziarnkoPieprzu in szczyptaPipeprzu){
              dodaj(ziarnkoPieprzu)
              }

              i mieszać, aż do momentu ścięcia się jajek

              A powinno wyglądać tak:

              patelnia.dodaj(maslo)
              patelnia.podgrzejDoRostopieniaMasla()
              patelnia.dodaj(pokroj(szynka))
              patelnia.dodaj(pokroj(szczypiorek))
              patelnia.dodaj(rozbij(jajko))
              patelnia.dodaj(sól)
              patelnia.dodaj(pieprz)
              mieszajDoMomentuScieciaSieJajek(patelnia)</p>
            <aside class="notes">
              Przepis na jajecznicę
              - Rozpuścić masło na małej patelni
              - Wrzucić na stopione masełko szynkę pokrojoną w małe kwadraciki oraz drobno posiekany szczypiorek
              - rozbić ostrym nożem skorupki jajek i zawartość wylewać na patelnię
              - Dodać trochę soli oraz pieprzu i mieszać, aż do momentu ścięcia się jajek

              i kod jak nie powinien i powinien wyglądać
            </aside>
          </section>
          <section>
            <h2>I właśnie po to są wzorce</h2>
            <p>
              Czasem nawet najładniej napisany kod nie obędzie się bez wzorców.
            </p>
            <aside class="notes">
              Po co o tym mowię? Przecież to szkolenie o wzorcach.
              Ponieważ mimo zastosowania wszystkich
              wspomnianych zabiegów okazało się że to i tak za mało aby utrzymać
              pełą kontrolę nad przepływem informacji pomiędzy obiektami.
              Mówię tutaj nie tylko o czytelnym ale też o logicznie poprawnym
              kodzie.

              Z pomocą przyszły wzorce projektowe.
            </aside>
          </section>
        </section>

        <!-- OBIEKTOWOŚĆ W PRAKTYCE? -->
        <section>
          <section>
            <h2>Obiektowość w praktyce</h2>
            <p>Krótkie przypomnienie obiektowości w ES6</p>
            <ul>
              <li>Tworzenie obiektów</li>
              <li>Definicja klasy</li>
              <li>Dziedziczenie</li>
              <li>Przesłanianie</li>
            </ul>
          </section>
          <section>
            <h2>Tworzenie obiektów</h2>
            <p>Kilka metod tworzenia obiektów</p>
            <pre><code data-trim data-noescape>
{}; // Object {}
new Object(); // Object {}
Object.create(null); // Object {} bez prototypu
            </code></pre>
            <aside class="notes">
              W js istnieje kilka metod tworzenia nowych obiektów. Popularne {}
              tworzą instancję klasy Object wraz z jej prototypem, tak samo jak
              słowo kluczowe new.
              Object.create(null) tworzy instancję klasy Object ale bez prototypu.
            </aside>
          </section>
          <section>
            <h2>Definicja klasy</h2>
            <p>Przypomnienie definiowanie klasy w ES6</p>
            <pre><code data-trim data-noescape>
// Przykład klasy definiującej kształt
class Shape {
  constructor() {
    this.x = 0;
    this.y = 0;
  }
  move(x, y) {
    this.x += x;
    this.y += y;
    console.info('Shape moved.');
  }
}

// Tworzenie instancji klasy Shape
let shape1 = new Shape();

// Wywołanie metody klasy Shape na obiekcie shape1
shape1.move(10, 10);
            </code></pre>
            <aside class="notes">
              Szkolenie ES6 było więc tylko przypominam jak definiuje się klasę.
              Shape jest nazwą naszej klasy, construktor jest metodą klasy która
              wywołuje się podczas instancjalizacji klasy - czyli podczas tworzenia
              nowego obiektu, innymi słowy tam gdzie jest napisane new Shape.
              move równierz jest metodą klasy ale move nie wywołuje się podczas
              tworzenia instancji. move możemy wywołać w odpowiednim dla nas momencie.
              Czyli Shape jest klasą, new Shape() tworzy nam instancję klasy Shape.
              shape1 jest obiektem typu Shape. A shape1.move jest wywołaniem metody.
            </aside>
          </section>
          <section>
            <h2>Dziedziczenie</h2>
            <p>Ale ja chcę kwadrat!</p>
            <pre><code data-trim data-noescape>
// Przykład klasy definiującej kwadrat dziedziczącej po kształcie
class Square extends Shape {
  constructor() {
    super(); // Wywołanie konstruktora z Shape - musi być przed thisem

    this.size = 10; // Dodane pole określające wielkość
  }

  // Dodana metoda do zmiany wielkośći kwadratu
  resize(size) {
    this.size = size;
  }
}

// Tworzenie kwadratu
let square1 = new Square();

// Wywołanie metody move na obiekcie square1
square1.move(20, 20);

// Wywołanie metody resize na obiekcie square1
square1.resize(20);
            </code></pre>
            <aside class="notes">
              Co w momencie kiedy chcemy mieć kwadrat a nie chcemy duplikować
              kodu pozycji który jest wewnątrz klasy Shape? Używamy słowa kluczowego
              extends i dziedziczymy po klasie Shape. W na pierwszy rzut oka
              tego nie widać ale ta klasa będzie posiadała pole zarówno size jak
              i x oraz y odziedziczone z Shape. Odziedziczyła równierz metodę
              move. [przekleić do konsoli]
            </aside>
          </section>
          <section>
            <h2>Przesłanianie</h2>
            <p>A co jeśli chcemy narysować Shape i Square. Dwie różne metody?</p>

            <pre><code data-trim data-noescape>
// Przykład klasy definiującej kształt
class Shape {
  constructor() {
    this.x = 0;
    this.y = 0;
  }
  move(x, y) {
    this.x += x;
    this.y += y;
    console.info('Shape moved.');
  }
  // Metoda do rysowania kształtu
  draw(ctx) {
     console.log(`${ctx}.fillRect(${this.x}, ${this.y}, 1, 1);`);
  }
}

// Tworzenie instancji klasy Shape
let shape1 = new Shape();

// Wywołanie metody draw klasy Shape na obiekcie shape1
shape1.draw();


// Przykład klasy definiującej kwadrat dziedziczącej po kształcie
class Square extends Shape {
  constructor() {
    super(); // Wywołanie konstruktora z Shape - musi być przed thisem

    this.size = 10; // Dodane pole określające wielkość
  }

  // Dodana metoda do zmiany wielkośći kwadratu
  resize(size) {
    this.size = size;
  }
  // Przesłonięta metoda do rysowania kształtu
  draw(ctx) {
    console.log(`${ctx}.fillRect(${this.x}, ${this.y}, ${this.size}, ${this.size});`);
  }
}

// Tworzenie kwadratu
let square1 = new Square();

// Wywołanie metody draw klasy Square na obiekcie square1
square1.draw();
            </code></pre>

            <aside class="notes">
              Mamy kształt mamy kwadrat chcemy je zobaczyć na canvasie przykładowo.
              Nie będziemy specjaline po to definiować oddzielnych metod dla
              Kształtu i dla Kwadratu. Potem chcąc wywołać rysowanie każdego z elementów
              w pętli musieli byśmy pamiętać o warunkach - jeżeli kształt to taka metoda,
              jeżeli kwadrat to taka. Korzystając z przesłonięcia metody możemy
              później wszystkie kształty - czy to kształt czy to kwadrat trzymać
              wewnątrz jednej pętli i nie musimy się zastanawiać jaką metodę wywołać.
            </aside>
          </section>
          <section>
            <h2>I właśnie po to są wzorce</h2>
            <p>
              Czasem nawet najładniej napisany kod nie obędzie się bez wzorców.
            </p>
            <aside class="notes">
              Po co o tym mowię? Przecież to szkolenie o wzorcach.
              Ponieważ mimo zastosowania wszystkich
              wspomnianych zabiegów okazało się że to i tak za mało aby utrzymać
              pełą kontrolę nad przepływem informacji pomiędzy obiektami.
              Mówię tutaj nie tylko o czytelnym ale też o logicznie poprawnym
              kodzie.

              Z pomocą przyszły wzorce projektowe.
            </aside>
          </section>
        </section>

        <section>
          <h2>Źródło</h2>
          <a href="https://developer.mozilla.org/pl/docs/Web/JavaScript">MDN</a>
        </section>
        <section>
          <h2>Dzięki</h2>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'socket.io/socket.io.js', async: true },
          { src: 'plugin/notes-server/client.js', async: true }
        ]
      });
    </script>
  </body>
</html>
