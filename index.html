<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Podstawy js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>Wzorce projektowe</h1>
          <h2>w praktyce</h2>
          <img src="https://pl.gravatar.com/userimage/96535938/f405f6eac9456fb4fe004bb989434528?size=200"/><br/>
          <a href="https://www.npmjs.com/~kociolekt">npm</a>, <a href="https://github.com/kociolekt">github</a>
        </section>
        <section>
          <h2>Agenda</h2>
          <ul>
            <li>O czym nie jest</li>
            <li>Po co?</li>
            <li>Singleton</li>
            <!--// Napisać eveter oparty na DOM-->
            <li>Mediator</li>
            <!--// Dobrym przykladem estimationEdit.js
            // Wersja sprzed przerobienia na mediatora
            // Wersja po przerobieniu na mediatora
            // Wnioski-->
            <li>Obserwator/Reactor</li>
            <!--// EstimationEdit, Costs, i inne widgety
            // Wersja sprzed przerobienia na Obserwator
            // Wersja po przerobieuniu na obserwator
            // Jakikolwiek eventer (Simple-Eventer lub wykorzystanie eventow DOM)-->
            <li>tbc</li>
          </ul>
        </section>
        <section>
          <h2>O czym nie jest</h2>
          <p>Dużo praktyki mało teorii</p>
          <ul>
            <li>Obiektowość - paradygmat programowania w informatyce</li>
            <li>Klasa - definicja obiektu</li>
            <li>Instancja - pojedynczy obiekt pewnej klasy</li>
            <li>Dziedziczenie - współdzielenie funkcjonalności</li>
            <li>Hermetyacja - ukrywanie składowych</li>
            <li>Wzorce - gotowe rozwiązania</li>
          </ul>
          <aside class="notes">
            Nie będę mówił o tym że obiektowość to zbiór pojęć i teorii wykorzystywanych w informatyce do programowania z pomocą klasy i obiektu.
            Nie będę też mówił o tym że obiektowość w javascriptcie to tylko imitacja obiektowości z obiektowych języków programowania.
            Nie powiem też że klasa jest częściową lub całkowitą definicja obiektu. Tak nawiasem mówiąc to nazwy klas pisze się wielką literą.
            Nie zamierzam też tłumaczyć że instancja jest pojedynczym wystąpieniem obiektu zgodnego z definicją zapisaną w Klasie.
            Nie chcę wspominać o dziedziczeniu jako mechanizmie współdzielenia fukcjonalności pomiędzy klsasami.
            Ani mi w głowie mówić o ukrywanie pewnych składowych elementów obiektu przy pomocy hermetyzacji;
            a juz na pewno nie będę zanudzał was teorią na temat uniwersalnych sprawdzonych w praktyce rozwiązań powtarzalnych problemów projektowych.
            Wszystkie te elementy postaram się pokazać od strony praktycznej.
          </aside>
        </section>
        <section>
          <section>
            <h2>Po co?</h2>
            <p>Do czego służą wzorce projektowe i po co nam one</p>
            <ul>
              <li>Jak to z Toolboxem było</li>
              <li>Najpierw myślimy potem robimy</li>
              <li>Poziomy abstrakcji</li>
              <li>Przykład z jajkiem</li>
              <li>I właśnie po to są wzorce</li>
            </ul>
          </section>
          <section>
            <h2>Toolbox</h2>
            <p>Duży projekt</p>
            <a href="img/toolbox.png" target="_blank"><img src="img/toolbox.png" /></a>
            <aside class="notes">
              Napisany w ostatnio bardzo popularnej architektórze mikroserwisów.
              Jak na razie składa się z kilkunastu serwisów z czego 8 z nich
              jako interfejs wykorzystuje technologie webowe.
              Wraz z modułami es6 weszła możliwość wygodniejszego definiowania klas.
              Postanowiłem zobaczyć jak sprawdzi się pisanie bardzo obiektowego kodu
              I zacząłem trafiać na problemy związane z komunikacją pomiędzy
              obiektami - przestałem orientować się który obiekt z którym się
              komunikuje w którym momencie.
            </aside>
          </section>
          <section>
            <h2>Najpierw myślimy potem robimy</h2>
            <p>Warto poświęcić chwilę żeby się zastanowić nim siądzie się do kodu. Nawet z kartką i długopisem w ręku.</p>
            <a href="img/toolbox.png" target="_blank"><img src="img/toolbox.png" /></a>
            <aside class="notes">
              Więc zastanowiłem się chwilę i rozpisałem sobie Hierarchię obiektów i metod.
              Analizując potrzeby projektu zauważyłem że łatwo można podzielić
              go na "warstwy" o różnym stopniu szczegółowości.
              W ten sposób podział skończyłem ze Splitem, Serwisem, Stroną, Widgetem,
              Komponentem i Pluginem.
              Do tego założyłem ograniczenia w wielkości klasy oraz metody.
              300 linijek dla klasy i 20 linijek dla metody.
              Nie wspomnę już o zasadzie że jedna metoda powinna wykonywać jedną czynność.
              Do tego każdy z elementów dzielę na funkcjonalności a metody uruchamiające
              funkcjonalności poprzedzam słowem init.
            </aside>
          </section>
          <section>
            <h2>Poziomy abstrakcji</h2>
            <p>Dodatkowy czinnik wpływający na jakość kodu.</p>
            <aside class="notes">
              Pozatym jest jeszcze jeden współczynnik który pomaga w organizacji
              kodu. W jednej z książek nazwali go poziomem abstrakcji.
              Pokażę to na przykładzie przepisu na jajecznicę.
            </aside>
          </section>
          <section>
            <h2>Przykład z jajkiem</h2>
            <p>                Przepis na jajecznicę
              - Rozpuścić masło na małej patelni
              - Wrzucić na stopione masełko szynkę pokrojoną w małe kwadraciki oraz drobno posiekany szczypiorek
              - rozbić ostrym nożem skorupki jajek i zawartość wylewać na patelnię
              - Dodać trochę soli oraz pieprzu i mieszać, aż do momentu ścięcia się jajek

              Często kodzie wygląda to tak:

              dodaj(maslo)

              while(maslo.nieJestStopione){
              for( atom in atomyWProbceMasla){
              atom.dostarczEnergii
              }
              }
              dodaj(pokrojona Szynka)

              while(szczypiorek.jestCaly){
              oddziaływuj nożem na sieć krystaliczną szczypiorku
              }

              dodaj(szczypiorek)

              noż.dodajEnerigiiPotencjalnej
              noz.zamieńEnergięPotencjalnąNaKinetyczną
              noż.uderzW(jajko)

              dodaj(zawartośćJajka)

              dodaj(sól)

              for(ziarnkoPieprzu in szczyptaPipeprzu){
              dodaj(ziarnkoPieprzu)
              }

              i mieszać, aż do momentu ścięcia się jajek

              A powinno wyglądać tak:

              patelnia.dodaj(maslo)
              patelnia.podgrzejDoRostopieniaMasla()
              patelnia.dodaj(pokroj(szynka))
              patelnia.dodaj(pokroj(szczypiorek))
              patelnia.dodaj(rozbij(jajko))
              patelnia.dodaj(sól)
              patelnia.dodaj(pieprz)
              mieszajDoMomentuScieciaSieJajek(patelnia)</p>
            <aside class="notes">
              Przepis na jajecznicę
              - Rozpuścić masło na małej patelni
              - Wrzucić na stopione masełko szynkę pokrojoną w małe kwadraciki oraz drobno posiekany szczypiorek
              - rozbić ostrym nożem skorupki jajek i zawartość wylewać na patelnię
              - Dodać trochę soli oraz pieprzu i mieszać, aż do momentu ścięcia się jajek

              i kod jak nie powinien i powinien wyglądać
            </aside>
          </section>
          <section>
            <h2>I właśnie po to są wzorce</h2>
            <p>
              Czasem nawet najładniej napisany kod nie obędzie się bez wzorców.
            </p>
            <aside class="notes">
              Po co o tym mowię? Przecież to szkolenie o wzorcach.
              Ponieważ mimo zastosowania wszystkich
              wspomnianych zabiegów okazało się że to i tak za mało aby utrzymać
              pełą kontrolę nad przepływem informacji pomiędzy obiektami.
              Mówię tutaj nie tylko o czytelnym ale też o logicznie poprawnym
              kodzie.

              Z pomocą przyszły wzorce projektowe.
            </aside>
          </section>
        </section>
        <section>
          <h2>Źródło</h2>
          <a href="https://developer.mozilla.org/pl/docs/Web/JavaScript">MDN</a>
        </section>
        <section>
          <h2>Dzięki</h2>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'socket.io/socket.io.js', async: true },
          { src: 'plugin/notes-server/client.js', async: true }
        ]
      });
    </script>
  </body>
</html>
