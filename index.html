<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Podstawy js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>Wzorce projektowe</h1>
          <h2>w praktyce</h2>
          <img src="https://pl.gravatar.com/userimage/96535938/f405f6eac9456fb4fe004bb989434528?size=200"/><br/>
          <a href="https://www.npmjs.com/~kociolekt">npm</a>, <a href="https://github.com/kociolekt">github</a>
        </section>
        <section>
          <h2>Agenda</h2>
          <ul>
            <li>Nie o tym</li>
            <li>Toolbox</li>
            <!--
            // Duży projekt
            //  Napisany w ostatnio bardzo popularnej architektórze mikroserwisów.
                Jak na razie składa się z kilkunastu serwisów z czego 8 z nich
                jako interfejs wykorzystuje technologie webowe.
            // Test podejścia
                Wraz z modułami es6 weszła możliwość wygodniejszego definiowania klas.
                Postanowiłem sprawdzić jak sprawdzi się pisanie bardzo obiektowego kodu
                I zacząłem trafiać na problemy związane z komunikacją pomiędzy
                obiektami - przestałem orientować się który obiekt z którym się
                komunikuje w którym momencie.
            // Najpierw myślimy potem robimy
                Więc zastanowiłem się chwilę i rozpisałem sobie Hierarchię obiektów i metod.
                Okazało się że ktoś coś podobnego już zrobił kiedys i nawet nazwał to poziomami abstrakcji.
            // Poziomy abstrakcji - Serwisy, strony, widgety, komponenty, pluginy
                Analizując potrzeby projektu zauważyłem że łatwo można podzielić
                go na "warstwy" o różnym stopniu szczegółowości.
                W ten sposób skończyłem ze Splitem, Serwisem, Stroną, Widgetem,
                Komponentem i Pluginem.
                Do tego założyłem ograniczenia w wielkości klasy oraz metody.
                300 linijek dla klasy i 20 linijek dla metody. Nie jest to gwarancją
                poprawnych poziomów abstrakcji ale pomaga.
                Do tego każdy z elementów dzielę na funkcjonalności a metody uruchamiające
                funkcjonalności poprzedzam słowem init.
                Po co o tym mowię? Ponieważ mimo zastosowania wszystkich
                wspomnianych zabiegów okazało się że to i tak za mało aby utrzymać
                pełą kontrolę nad przepływem informacji pomiędzy obiektami.
            // Przykład w jajkiem

            // Ograniczenie ilości linijek w funkcjach do 20 i klasach do 300-->

            <li>Singleton</li>
            <!--// Napisać eveter oparty na DOM-->
            <li>Mediator</li>
            <!--// Dobrym przykladem estimationEdit.js
            // Wersja sprzed przerobienia na mediatora
            // Wersja po przerobieniu na mediatora
            // Wnioski-->
            <li>Obserwator/Reactor</li>
            <!--// EstimationEdit, Costs, i inne widgety
            // Wersja sprzed przerobienia na Obserwator
            // Wersja po przerobieuniu na obserwator
            // Jakikolwiek eventer (Simple-Eventer lub wykorzystanie eventow DOM)-->
            <li>tbc</li>
          </ul>
        </section>
        <section>
          <h2>Nie o tym</h2>
          <p>Nic będę porószał nic z teorii</p>
          <ul>
            <li>Obiektowość - paradygmat programowania w informatyce</li>
            <li>Klasa - definicja obiektu</li>
            <li>Instancja - pojedynczy obiekt pewnej klasy</li>
            <li>Dziedziczenie - współdzielenie funkcjonalności</li>
            <li>Hermetyacja - ukrywanie składowych</li>
            <li>Wzorce - gotowe rozwiązania</li>
          </ul>
          <aside class="notes">
            Nie będę mówił o tym że obiektowość to zbiór pojęć i teorii wykorzystywanych w informatyce do programowania z pomocą klasy i obiektu.
            Nie będę też mówił o tym że obiektowość w javascriptcie to tylko imitacja obiektowości z obiektowych języków programowania.
            Nie powiem też że klasa jest częściową lub całkowitą definicja obiektu. Tak nawiasem mówiąc to nazwy klas pisze się wielką literą.
            Nie zamierzam też tłumaczyć że instancja jest pojedynczym wystąpieniem obiektu zgodnego z definicją zapisaną w Klasie.
            Nie chcę wspominać o dziedziczeniu jako mechanizmie współdzielenia fukcjonalności pomiędzy klsasami.
            Ani mi w głowie mówić o ukrywanie pewnych spkładowych elementów obiektu przy pomocy hermetyzacji;
            a juz na pewno nie będę zanudzał was teorią na temat uniwersalnych sprawdzonych w praktyce rozwiązań powtarzalnych problemów projektowych.
            Wszystkie te elementy postaram się pokazać od strony praktycznej.
          </aside>
        </section>
        <section>
          <h2>Źródło</h2>
          <a href="https://developer.mozilla.org/pl/docs/Web/JavaScript">MDN</a>
        </section>
        <section>
          <h2>Dzięki</h2>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'socket.io/socket.io.js', async: true },
          { src: 'plugin/notes-server/client.js', async: true }
        ]
      });
    </script>
  </body>
</html>
